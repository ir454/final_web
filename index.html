<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Audio Visual Experience with Audio Files</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
  canvas { display: block; }
  #uiContainer {
    position: absolute;
    top: 10px; left: 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    background: rgba(0,0,0,0.4);
    padding: 10px;
    border-radius: 8px;
  }
  #timer { font-size: 28px; color: white; font-weight: bold; text-align: center; }
  #startAudio {
    padding: 8px 16px;
    background: #ff4444;
    color: white;
    font-size: 16px;
    border: none;
    cursor: pointer;
    border-radius: 6px;
  }
  #miniMap {
    width: 150px;
    height: 150px;
    background: #111;
    border: 2px solid white;
    border-radius: 6px;
    cursor: pointer;
  }
  #controls {
    color: white;
    font-size: 14px;
    background: rgba(0,0,0,0.45);
    padding: 8px;
    border-radius: 6px;
    line-height: 1.3em;
  }
  #controls ul { margin: 6px 0 0 16px; padding: 0; list-style-type: disc; }
  #controls li { margin-bottom: 3px; }
</style>
</head>
<body>
<div id="uiContainer">
  <div id="timer">05:00</div>
  <canvas id="miniMap"></canvas>
  <button id="startAudio">Click to Enable Sound</button>
  <div id="controls">
    <strong>Controls:</strong>
    <ul>
      <li>Move: W A S D</li>
      <li>Look: Arrow Keys</li>
      <li>Move Circle to You: 1â€“8</li>
      <li>Mini-Map: Click a circle, then drag to move it</li>
    </ul>
  </div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

/* ======================== SCENE ======================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0,1.5,15);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ======================== FLOOR ======================== */
const floorSize = 60;
const floorGeometry = new THREE.PlaneGeometry(floorSize,floorSize,60,60);
const floorMaterial = new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true, transparent:true, opacity:0.5});
const floorMesh = new THREE.Mesh(floorGeometry,floorMaterial);
floorMesh.rotation.x = -Math.PI/2;
scene.add(floorMesh);

/* ======================== LIGHT ======================== */
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(5,10,7);
scene.add(light);

/* ======================== CIRCLES ======================== */
const circles = [];
const circlePositions = [
  new THREE.Vector3(-10,0.5,-10),
  new THREE.Vector3(10,0.5,-10),
  new THREE.Vector3(-10,0.5,10),
  new THREE.Vector3(10,0.5,10),
  new THREE.Vector3(-5,0.5,0),
  new THREE.Vector3(5,0.5,0),
  new THREE.Vector3(0,0.5,-5),
  new THREE.Vector3(0,0.5,5)
];
const neonColors = [0xff00ff,0x00ffff,0xffff00,0xff5500,0xff0055,0x55ff00,0x0055ff,0xffaa00];

for(let i=0;i<8;i++){
  const mat = new THREE.MeshStandardMaterial({
    color: neonColors[i],
    emissive: neonColors[i],
    emissiveIntensity: 0.6
  });
  const circle = new THREE.Mesh(new THREE.SphereGeometry(1,16,16), mat);
  circle.position.copy(circlePositions[i]);
  scene.add(circle);
  circles.push({mesh: circle, currentColor: new THREE.Color(neonColors[i]), targetColor: new THREE.Color(neonColors[i]), baseY: circle.position.y});
}

/* ======================== SEGMENTS ======================== */
const segmentsPerCircle = 15;
const circleSegments = [];
for(let i=0;i<8;i++){
  const segs = [];
  for(let j=0;j<segmentsPerCircle;j++){
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6),3));
    const line = new THREE.Line(geom,new THREE.LineBasicMaterial({color: neonColors[i]}));
    scene.add(line);
    segs.push({line, geom});
  }
  circleSegments.push(segs);
}

/* ======================== USER MOVEMENT ======================== */
const keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => delete keys[e.key]);

let yaw = 0, pitch = 0;

function updateMovement(){
  const moveSpeed = 0.13, rotSpeed = 0.02;

  if(keys["ArrowLeft"]) yaw += rotSpeed;
  if(keys["ArrowRight"]) yaw -= rotSpeed;
  if(keys["ArrowUp"]) pitch += rotSpeed;
  if(keys["ArrowDown"]) pitch -= rotSpeed;

  camera.rotation.set(pitch, yaw, 0);

  const forward = new THREE.Vector3(-Math.sin(yaw),0,-Math.cos(yaw));
  const right = new THREE.Vector3(Math.cos(yaw),0,-Math.sin(yaw));

  if(keys["w"]||keys["W"]) camera.position.addScaledVector(forward, moveSpeed);
  if(keys["s"]||keys["S"]) camera.position.addScaledVector(forward, -moveSpeed);
  if(keys["a"]||keys["A"]) camera.position.addScaledVector(right, -moveSpeed);
  if(keys["d"]||keys["D"]) camera.position.addScaledVector(right, moveSpeed);

  // Move circles to player
  ["1","2","3","4","5","6","7","8"].forEach((k,i)=>{
    if(keys[k]){
      circles[i].mesh.position.copy(camera.position);
      circles[i].mesh.position.y = 1;
      delete keys[k];
    }
  });
}

/* ======================== AUDIO USING FILES ======================== */
let audioCtx, circleAudioArray = [];
let audioStarted = false;

const totalCircles = 8;
const audioFiles = [
  "audio/circle1.mp3",
  "audio/circle2.mp3",
  "audio/circle3.mp3",
  "audio/circle4.mp3",
  "audio/circle5.mp3",
  "audio/circle6.mp3",
  "audio/circle7.mp3",
  "audio/circle8.mp3"
];

async function startAudio(){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    for(let i=0;i<totalCircles;i++){
        const response = await fetch(audioFiles[i]);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

        const source = audioCtx.createBufferSource();
        source.buffer = audioBuffer;
        source.loop = true;

        const panner = audioCtx.createPanner();
        panner.panningModel = "HRTF";
        panner.distanceModel = "inverse";

        const gain = audioCtx.createGain();
        gain.gain.value = 0.3;

        source.connect(panner);
        panner.connect(gain);
        gain.connect(audioCtx.destination);

        source.start();

        circleAudioArray.push({
            source,
            gain,
            panner
        });
    }

    audioStarted = true;
    document.getElementById("startAudio").style.display = "none";
    startTimer();
}

/* ======================== TIMER ======================== */
let timerSeconds = 300;
let timerInterval = null;

function startTimer(){
  timerInterval = setInterval(()=>{
    timerSeconds--;
    if(timerSeconds<=0){
      clearInterval(timerInterval);
      stopAudio();
    }
    const min = String(Math.floor(timerSeconds/60)).padStart(2,'0');
    const sec = String(timerSeconds%60).padStart(2,'0');
    document.getElementById("timer").innerText = `${min}:${sec}`;
  },1000);
}

/* ======================== SPATIAL AUDIO ======================== */
function updateAudioSpatial(){
    if(!audioStarted) return;

    // Listener position
    audioCtx.listener.positionX.value = camera.position.x;
    audioCtx.listener.positionY.value = camera.position.y;
    audioCtx.listener.positionZ.value = camera.position.z;

    const forward = new THREE.Vector3(0,0,-1).applyEuler(camera.rotation);
    audioCtx.listener.forwardX.value = forward.x;
    audioCtx.listener.forwardY.value = forward.y;
    audioCtx.listener.forwardZ.value = forward.z;

    audioCtx.listener.upX.value = 0;
    audioCtx.listener.upY.value = 1;
    audioCtx.listener.upZ.value = 0;

    // Circles
    for(let i=0;i<totalCircles;i++){
        const pos = circles[i].mesh.position;
        const audioObj = circleAudioArray[i];

        audioObj.panner.positionX.value = pos.x;
        audioObj.panner.positionY.value = pos.y;
        audioObj.panner.positionZ.value = pos.z;

        const dist = camera.position.distanceTo(pos);
        const t = Math.min(dist/25,1);
        const vol = Math.pow(1-t,3);
        audioObj.gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime+0.1);
    }
}

/* ======================== VISUALS ======================== */
function updateCirclesVisuals(){
  const time = performance.now()/1000;
  for(let i=0;i<totalCircles;i++){
    const c = circles[i];
    c.mesh.position.y = c.baseY + Math.sin(time+i)*0.3;
    c.currentColor.lerp(c.targetColor,0.02);
    c.mesh.material.color.copy(c.currentColor);
    c.mesh.material.emissive.copy(c.currentColor);

    const segs = circleSegments[i];
    for(let j=0;j<segs.length;j++){
      const seg = segs[j];
      const len = 1 + 0.5*Math.sin(time+j);
      const pos = seg.geom.attributes.position.array;
      pos[0]=0; pos[1]=0; pos[2]=0;
      pos[3]=0; pos[4]=len; pos[5]=0;
      seg.geom.attributes.position.needsUpdate=true;
      seg.line.material.color.copy(c.currentColor);
    }
  }
}

/* ======================== MINI-MAP ======================== */
const miniMap=document.getElementById("miniMap");
const miniCtx=miniMap.getContext("2d");
const dpi=window.devicePixelRatio||1;
miniMap.width=miniMap.clientWidth*dpi;
miniMap.height=miniMap.clientHeight*dpi;
miniCtx.scale(dpi,dpi);

let selectedCircleIndex=null, dragging=false;

function miniMapToWorld(mx,my){
  const worldX=(mx/miniMap.width)*floorSize - floorSize/2;
  const worldZ=(my/miniMap.height)*floorSize - floorSize/2;
  return {worldX,worldZ};
}

miniMap.addEventListener("mousedown",(e)=>{
  const rect=miniMap.getBoundingClientRect();
  const mx=(e.clientX-rect.left)*(miniMap.width/rect.width);
  const my=(e.clientY-rect.top)*(miniMap.height/rect.height);

  selectedCircleIndex=null; dragging=false;

  for(let i=0;i<circles.length;i++){
    const cx=(circles[i].mesh.position.x+floorSize/2)/floorSize*miniMap.width;
    const cy=(circles[i].mesh.position.z+floorSize/2)/floorSize*miniMap.height;
    const dx=mx-cx, dy=my-cy;
    if(dx*dx+dy*dy<25){selectedCircleIndex=i; dragging=true; return;}
  }
});
miniMap.addEventListener("mousemove",(e)=>{
  if(!dragging||selectedCircleIndex===null) return;
  const rect=miniMap.getBoundingClientRect();
  const mx=(e.clientX-rect.left)*(miniMap.width/rect.width);
  const my=(e.clientY-rect.top)*(miniMap.height/rect.height);
  const {worldX,worldZ}=miniMapToWorld(mx,my);
  circles[selectedCircleIndex].mesh.position.set(worldX,1,worldZ);
});
["mouseup","mouseleave"].forEach(ev=>miniMap.addEventListener(ev,()=>{dragging=false; selectedCircleIndex=null;}));

function updateMiniMap(){
  miniCtx.clearRect(0,0,miniMap.width,miniMap.height);
  circles.forEach(c=>{
    const x=(c.mesh.position.x+floorSize/2)/floorSize*miniMap.width/dpi;
    const y=(c.mesh.position.z+floorSize/2)/floorSize*miniMap.height/dpi;
    miniCtx.beginPath();
    miniCtx.arc(x,y,5,0,Math.PI*2);
    miniCtx.fillStyle=`#${c.currentColor.getHexString()}`;
    miniCtx.fill();
  });
  const userX=(camera.position.x+floorSize/2)/floorSize*miniMap.width/dpi;
  const userY=(camera.position.z+floorSize/2)/floorSize*miniMap.height/dpi;
  miniCtx.beginPath();
  miniCtx.arc(userX,userY,5,0,Math.PI*2);
  miniCtx.fillStyle="red";
  miniCtx.fill();
}

/* ======================== STOP AUDIO ======================== */
function stopAudio(){
  if(!audioStarted) return;
  circleAudioArray.forEach(c=>{
    c.gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.05);
    c.source.stop(audioCtx.currentTime+0.05);
  });
}

/* ======================== ANIMATION LOOP ======================== */
function animate(){
  requestAnimationFrame(animate);
  updateMovement();
  updateAudioSpatial();
  updateCirclesVisuals();
  updateMiniMap();
  renderer.render(scene,camera);
}
animate();

/* ======================== BUTTON ======================== */
document.getElementById("startAudio").addEventListener("click", startAudio);

/* ======================== WINDOW RESIZE ======================== */
window.addEventListener("resize",()=>{ 
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
